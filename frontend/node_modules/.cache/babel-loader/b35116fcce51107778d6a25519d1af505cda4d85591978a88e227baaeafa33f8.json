{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect, useRef } from 'react';\nimport { useWhatsAppStore } from '../store/useWhatsAppStore';\nimport { config } from '../config';\n\n// Constantes para controle de throttling\nconst REQUEST_TIMEOUT = 15000; // 15 segundos\nconst RETRY_ATTEMPTS = 2;\nconst RETRY_DELAY = 3000; // 3 segundos\nconst SYNC_THROTTLE_INTERVAL = 10000; // 10 segundos (aumentado)\nconst MESSAGE_DUPLICATE_THRESHOLD = 60000; // 1 minuto\nconst STATUS_CHECK_INTERVAL = 15000; // 15 segundos\nconst SYNC_INTERVAL = 30000; // 30 segundos (aumentado)\n\n// URL base para API do WhatsApp\nconst WHATSAPP_API_BASE = config.whatsapp.apiUrl;\n\n// Fun√ß√£o de retry com exponential backoff\nconst retryRequest = async (requestFn, maxRetries = RETRY_ATTEMPTS, baseDelay = RETRY_DELAY) => {\n  let lastError;\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await requestFn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      if (attempt === maxRetries) {\n        throw lastError;\n      }\n\n      // Exponential backoff com jitter\n      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;\n      console.log(`‚ö†Ô∏è Tentativa ${attempt + 1} falhou, aguardando ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  throw lastError;\n};\n\n// Fun√ß√£o de fetch com timeout\nconst fetchWithTimeout = async (url, options = {}) => {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      }\n    });\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timeout');\n    }\n    throw error;\n  }\n};\nexport const useWhatsAppSync = () => {\n  _s();\n  const {\n    connectionStatus,\n    connectWhatsApp,\n    disconnectWhatsApp,\n    chats,\n    contacts,\n    addMessage,\n    updateChat,\n    loadChatsFromServer,\n    loadMessagesForChat\n  } = useWhatsAppStore();\n  const [lastSync, setLastSync] = useState(null);\n  const [syncError, setSyncError] = useState(null);\n  const [isRetrying, setIsRetrying] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [syncInProgress, setSyncInProgress] = useState(false);\n  const [lastOperationTime, setLastOperationTime] = useState(0);\n\n  // Refs para controle de opera√ß√µes\n  const syncTimeoutRef = useRef(null);\n  const statusTimeoutRef = useRef(null);\n  const isInitializingRef = useRef(false);\n\n  // Verificar se opera√ß√£o √© muito recente\n  const isRecentOperation = (operation, threshold = SYNC_THROTTLE_INTERVAL) => {\n    const now = Date.now();\n    return now - lastOperationTime < threshold;\n  };\n\n  // Verificar status da conex√£o WhatsApp com retry\n  const checkWhatsAppStatus = useCallback(async () => {\n    if (isRecentOperation('checkStatus', STATUS_CHECK_INTERVAL)) {\n      console.log('‚ö†Ô∏è Verifica√ß√£o de status muito recente, pulando...');\n      return {\n        whatsappConnected: false,\n        connected: false\n      };\n    }\n    try {\n      console.log('üîç Verificando status do WhatsApp...');\n      setLastOperationTime(Date.now());\n      const response = await retryRequest(() => fetchWithTimeout(`${WHATSAPP_API_BASE}/api/status`));\n      if (!response.ok) {\n        if (response.status === 429) {\n          console.log('‚ö†Ô∏è Rate limit atingido, aguardando...');\n          // Aguardar um pouco antes de tentar novamente\n          await new Promise(resolve => setTimeout(resolve, 2000));\n          throw new Error(`HTTP 429: Rate limit exceeded - aguarde um momento`);\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('‚úÖ Status do WhatsApp:', data);\n\n      // Atualizar estado baseado na resposta\n      const isConnected = data.whatsappConnected || data.connected || false;\n      if (isConnected && connectionStatus !== 'connected') {\n        console.log('üîó WhatsApp conectado, atualizando estado...');\n        connectWhatsApp();\n      } else if (!isConnected && connectionStatus === 'connected') {\n        console.log('üîå WhatsApp desconectado, atualizando estado...');\n        disconnectWhatsApp();\n      }\n      setSyncError(null);\n      setIsRetrying(false);\n      return data;\n    } catch (error) {\n      console.error('‚ùå Erro ao verificar status WhatsApp:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      setSyncError(`Erro de conex√£o: ${errorMsg}`);\n      if (connectionStatus === 'connected') {\n        disconnectWhatsApp();\n      }\n      return {\n        whatsappConnected: false,\n        error: errorMsg,\n        connected: false\n      };\n    }\n  }, [connectionStatus, connectWhatsApp, disconnectWhatsApp, isRecentOperation]);\n\n  // Sincronizar chats do servidor WhatsApp real com retry\n  const syncChats = useCallback(async () => {\n    if (isRecentOperation('syncChats', SYNC_THROTTLE_INTERVAL)) {\n      console.log('‚ö†Ô∏è Sincroniza√ß√£o de chats muito recente, pulando...');\n      return [];\n    }\n    try {\n      console.log('üîÑ Sincronizando chats do WhatsApp...');\n      setLastOperationTime(Date.now());\n      const response = await retryRequest(() => fetchWithTimeout(`${WHATSAPP_API_BASE}/api/chats`));\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const data = await response.json();\n      if (data.chats && Array.isArray(data.chats)) {\n        // Converter formato do servidor para formato do store\n        const convertedChats = data.chats.map(serverChat => ({\n          id: serverChat.id,\n          contact: {\n            id: serverChat.id,\n            name: serverChat.name || 'Contato',\n            phone: serverChat.id.replace('@c.us', '').replace('@g.us', ''),\n            phoneNumber: serverChat.id.replace('@c.us', '').replace('@g.us', ''),\n            isOnline: false,\n            tags: ['WhatsApp']\n          },\n          messages: [],\n          // Mensagens ser√£o carregadas individualmente\n          lastMessage: serverChat.lastMessage ? {\n            id: 'last-' + serverChat.id,\n            content: typeof serverChat.lastMessage === 'string' ? serverChat.lastMessage : typeof serverChat.lastMessage === 'object' && serverChat.lastMessage.body ? serverChat.lastMessage.body : 'Mensagem',\n            timestamp: new Date((serverChat.timestamp || Date.now()) * 1000),\n            isFromMe: false,\n            status: 'read',\n            type: 'text'\n          } : undefined,\n          unreadCount: serverChat.unreadCount || 0,\n          isPinned: false,\n          isArchived: false,\n          createdAt: new Date((serverChat.timestamp || Date.now()) * 1000)\n        }));\n        console.log(`‚úÖ Sincronizados ${convertedChats.length} chats do WhatsApp`);\n\n        // ATUALIZAR O STORE com os chats reais\n        loadChatsFromServer(convertedChats);\n        setSyncError(null);\n        return convertedChats;\n      }\n      console.log('‚ö†Ô∏è Nenhum chat encontrado ou formato inv√°lido');\n      return [];\n    } catch (error) {\n      console.error('‚ùå Erro ao sincronizar chats:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      setSyncError(`Erro ao carregar conversas: ${errorMsg}`);\n      throw error;\n    }\n  }, [loadChatsFromServer, isRecentOperation]);\n\n  // Sincronizar mensagens de um chat espec√≠fico com retry\n  const syncChatMessages = useCallback(async chatId => {\n    try {\n      console.log(`üîÑ Carregando mensagens para chat: ${chatId}`);\n      setLastOperationTime(Date.now());\n      const response = await retryRequest(() => fetchWithTimeout(`${WHATSAPP_API_BASE}/api/chats/${encodeURIComponent(chatId)}/messages?limit=100`));\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const data = await response.json();\n      if (data.messages && Array.isArray(data.messages)) {\n        const convertedMessages = data.messages.map(serverMsg => ({\n          id: serverMsg.id || `msg-${Date.now()}-${Math.random()}`,\n          content: serverMsg.body || serverMsg.content || '',\n          timestamp: new Date((serverMsg.timestamp || Date.now()) * 1000),\n          isFromMe: serverMsg.fromMe || false,\n          status: 'read',\n          type: serverMsg.hasMedia ? 'document' : 'text'\n        }));\n\n        // Ordenar mensagens por timestamp (mais antiga primeiro para a interface)\n        const sortedMessages = convertedMessages.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n        console.log(`‚úÖ Carregadas ${sortedMessages.length} mensagens do servidor para chat ${chatId}`);\n        if (sortedMessages.length > 0) {\n          console.log('üìã Primeiras 3 mensagens:', sortedMessages.slice(0, 3).map(m => ({\n            id: m.id,\n            content: m.content.substring(0, 50),\n            timestamp: m.timestamp.toISOString()\n          })));\n        }\n\n        // ATUALIZAR O STORE com as mensagens reais (preservando hist√≥rico)\n        loadMessagesForChat(chatId, sortedMessages);\n        return sortedMessages;\n      }\n      console.log(`‚ö†Ô∏è Nenhuma mensagem encontrada no servidor para chat ${chatId}`);\n      return [];\n    } catch (error) {\n      console.error('‚ùå Erro ao sincronizar mensagens:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      throw new Error(`Erro ao carregar mensagens: ${errorMsg}`);\n    }\n  }, [loadMessagesForChat]);\n\n  // Enviar mensagem atrav√©s do servidor WhatsApp com retry\n  const sendMessage = useCallback(async (chatId, message) => {\n    if (isRecentOperation('sendMessage', 2000)) {\n      // 2 segundos para envio\n      console.log('‚ö†Ô∏è Envio de mensagem muito recente, aguarde...');\n      throw new Error('Envio muito frequente, aguarde um momento');\n    }\n    try {\n      console.log(`üì§ Enviando mensagem para ${chatId}: ${message}`);\n      setLastOperationTime(Date.now());\n      const response = await retryRequest(() => fetchWithTimeout(`${WHATSAPP_API_BASE}/api/send-message`, {\n        method: 'POST',\n        body: JSON.stringify({\n          number: chatId,\n          message: message\n        })\n      }));\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.error || 'Erro ao enviar mensagem');\n      }\n      console.log('‚úÖ Mensagem enviada com sucesso');\n\n      // Adicionar mensagem ao store localmente para feedback imediato\n      const newMessage = {\n        id: `sent-${Date.now()}-${Math.random()}`,\n        content: message,\n        timestamp: new Date(),\n        isFromMe: true,\n        status: 'sent',\n        type: 'text'\n      };\n      addMessage(chatId, newMessage);\n\n      // Aguardar um pouco e verificar se a mensagem foi realmente enviada\n      setTimeout(async () => {\n        try {\n          console.log('üîÑ Verificando se mensagem foi enviada com sucesso...');\n\n          // Verificar status da mensagem no servidor\n          const statusResponse = await fetchWithTimeout(`${WHATSAPP_API_BASE}/api/status`);\n          if (statusResponse.ok) {\n            const statusData = await statusResponse.json();\n            console.log('‚úÖ Servidor WhatsApp confirmou envio');\n\n            // For√ßar sincroniza√ß√£o das mensagens para garantir que apare√ßa\n            setTimeout(async () => {\n              try {\n                console.log('üîÑ Sincronizando mensagens ap√≥s envio...');\n                await syncChatMessages(chatId);\n              } catch (error) {\n                console.error('‚ö†Ô∏è Erro na sincroniza√ß√£o p√≥s-envio:', error);\n              }\n            }, 2000);\n\n            // Atualizar status da mensagem para 'delivered'\n            const {\n              chats\n            } = useWhatsAppStore.getState();\n            const updatedChats = chats.map(chat => {\n              if (chat.id === chatId) {\n                const updatedMessages = chat.messages.map(msg => {\n                  if (msg.id === newMessage.id) {\n                    return {\n                      ...msg,\n                      status: 'delivered'\n                    };\n                  }\n                  return msg;\n                });\n                return {\n                  ...chat,\n                  messages: updatedMessages\n                };\n              }\n              return chat;\n            });\n            useWhatsAppStore.setState({\n              chats: updatedChats\n            });\n          }\n        } catch (error) {\n          console.error('‚ö†Ô∏è Erro ao verificar status da mensagem:', error);\n        }\n      }, 3000); // Aguardar 3 segundos para o servidor processar\n\n      return true;\n    } catch (error) {\n      console.error('‚ùå Erro ao enviar mensagem:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n\n      // Adicionar mensagem de erro local\n      const errorMessage = {\n        id: `error-${Date.now()}-${Math.random()}`,\n        content: `‚ùå Erro ao enviar: ${errorMsg}`,\n        timestamp: new Date(),\n        isFromMe: false,\n        status: 'read',\n        type: 'text'\n      };\n      addMessage(chatId, errorMessage);\n      throw new Error(`Falha no envio: ${errorMsg}`);\n    }\n  }, [addMessage, isRecentOperation, syncChatMessages]);\n\n  // Fun√ß√£o de fallback para envio via endpoint alternativo\n  const sendMessageFallback = useCallback(async (chatId, message) => {\n    try {\n      console.log(`üì§ Tentando envio via endpoint alternativo para ${chatId}: ${message}`);\n      const response = await retryRequest(() => fetchWithTimeout(`${WHATSAPP_API_BASE}/api/whatsapp/send`, {\n        method: 'POST',\n        body: JSON.stringify({\n          number: chatId,\n          message: message\n        })\n      }));\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n      const result = await response.json();\n      if (!result.success) {\n        throw new Error(result.error || 'Erro ao enviar mensagem');\n      }\n      console.log('‚úÖ Mensagem enviada via endpoint alternativo');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Erro no endpoint alternativo:', error);\n      throw error;\n    }\n  }, []);\n\n  // Fun√ß√£o de envio com fallback\n  const sendMessageWithFallback = useCallback(async (chatId, message) => {\n    try {\n      return await sendMessage(chatId, message);\n    } catch (error) {\n      console.log('‚ö†Ô∏è Primeiro endpoint falhou, tentando alternativo...');\n      try {\n        return await sendMessageFallback(chatId, message);\n      } catch (fallbackError) {\n        console.error('‚ùå Ambos os endpoints falharam:', fallbackError);\n        throw fallbackError;\n      }\n    }\n  }, [sendMessage, sendMessageFallback]);\n\n  // Sincroniza√ß√£o autom√°tica quando conectado (COM DEBOUNCE)\n  const syncData = useCallback(async () => {\n    if (connectionStatus === 'connected' && !syncInProgress) {\n      try {\n        console.log('üîÑ Sincronizando dados do WhatsApp...');\n        setSyncInProgress(true);\n\n        // Verificar status primeiro\n        const status = await checkWhatsAppStatus();\n        if (status.whatsappConnected || status.connected) {\n          // S√≥ sincronizar se WhatsApp estiver conectado\n          const chats = await syncChats();\n          setLastSync(new Date());\n          setSyncError(null);\n          console.log('‚úÖ Sincroniza√ß√£o conclu√≠da');\n\n          // Sincronizar mensagens de todos os chats\n          if (chats.length > 0) {\n            console.log('üîÑ Sincronizando mensagens de todos os chats...');\n            for (const chat of chats) {\n              try {\n                await syncChatMessages(chat.id);\n              } catch (error) {\n                console.error(`‚ùå Erro ao sincronizar mensagens do chat ${chat.id}:`, error);\n              }\n            }\n          }\n        } else {\n          console.log('‚ö†Ô∏è WhatsApp n√£o conectado, pulando sincroniza√ß√£o');\n          setSyncError('WhatsApp n√£o conectado no servidor');\n        }\n      } catch (error) {\n        console.error('‚ùå Erro na sincroniza√ß√£o:', error);\n        const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n        setSyncError(`Erro na sincroniza√ß√£o: ${errorMsg}`);\n      } finally {\n        setSyncInProgress(false);\n      }\n    }\n  }, [connectionStatus, checkWhatsAppStatus, syncChats, syncChatMessages, syncInProgress]);\n\n  // Auto-reconex√£o em caso de desconex√£o\n  const handleReconnect = useCallback(async () => {\n    if (connectionStatus === 'error' || connectionStatus === 'disconnected') {\n      console.log('üîÑ Verificando possibilidade de reconex√£o...');\n      setIsRetrying(true);\n      try {\n        const status = await checkWhatsAppStatus();\n        if (status.whatsappConnected || status.connected) {\n          console.log('‚úÖ Reconectando WhatsApp...');\n          connectWhatsApp();\n        } else {\n          console.log('‚ö†Ô∏è WhatsApp ainda n√£o conectado no servidor');\n        }\n      } catch (error) {\n        console.log('‚ö†Ô∏è Servidor WhatsApp indispon√≠vel, tentando novamente em breve...');\n      } finally {\n        setIsRetrying(false);\n      }\n    }\n  }, [connectionStatus, checkWhatsAppStatus, connectWhatsApp]);\n\n  // Efeito para verifica√ß√£o inicial (apenas uma vez)\n  useEffect(() => {\n    if (!isInitialized && !isInitializingRef.current) {\n      console.log('üöÄ Inicializando useWhatsAppSync...');\n      isInitializingRef.current = true;\n      setIsInitialized(true);\n\n      // Delay para evitar chamadas simult√¢neas\n      const timeout = setTimeout(() => {\n        checkWhatsAppStatus();\n        isInitializingRef.current = false;\n      }, 2000); // Aumentado para 2 segundos\n\n      return () => {\n        clearTimeout(timeout);\n        isInitializingRef.current = false;\n      };\n    }\n  }, [isInitialized, checkWhatsAppStatus]);\n\n  // Efeito para sincroniza√ß√£o autom√°tica quando conectado (COM DEBOUNCE)\n  useEffect(() => {\n    if (connectionStatus === 'connected' && !syncInProgress) {\n      console.log('üîó WhatsApp conectado, iniciando sincroniza√ß√£o autom√°tica...');\n\n      // Primeira sincroniza√ß√£o imediata\n      const initialSync = setTimeout(() => {\n        if (connectionStatus === 'connected') {\n          syncData();\n        }\n      }, 1000); // Delay reduzido para 1 segundo\n\n      // Sincroniza√ß√£o peri√≥dica mais frequente\n      const interval = setInterval(() => {\n        if (connectionStatus === 'connected' && !syncInProgress) {\n          syncData();\n        }\n      }, 10000); // A cada 10 segundos\n\n      return () => {\n        console.log('üõë Parando sincroniza√ß√£o autom√°tica');\n        clearTimeout(initialSync);\n        clearInterval(interval);\n      };\n    }\n  }, [connectionStatus, syncData, syncInProgress]);\n\n  // Efeito para verifica√ß√£o peri√≥dica de status (separado da sincroniza√ß√£o)\n  useEffect(() => {\n    if (connectionStatus === 'connected') {\n      // Limpar timeout anterior\n      if (statusTimeoutRef.current) {\n        clearTimeout(statusTimeoutRef.current);\n      }\n\n      // Verifica√ß√£o peri√≥dica de status\n      statusTimeoutRef.current = setTimeout(() => {\n        if (connectionStatus === 'connected') {\n          checkWhatsAppStatus();\n        }\n      }, STATUS_CHECK_INTERVAL);\n      return () => {\n        if (statusTimeoutRef.current) {\n          clearTimeout(statusTimeoutRef.current);\n        }\n      };\n    }\n  }, [connectionStatus, checkWhatsAppStatus]);\n\n  // Efeito para tentativa de reconex√£o (com debounce maior)\n  useEffect(() => {\n    if (connectionStatus === 'error' || connectionStatus === 'disconnected') {\n      // Delay maior para evitar spam de reconex√£o\n      const timeout = setTimeout(handleReconnect, config.whatsapp.reconnectInterval * 3);\n      return () => clearTimeout(timeout);\n    }\n  }, [connectionStatus, handleReconnect]);\n\n  // Debug: log do estado atual\n  useEffect(() => {\n    console.log('üìä Estado useWhatsAppSync:', {\n      connectionStatus,\n      totalChats: chats.length,\n      totalContacts: contacts.length,\n      lastSync: lastSync === null || lastSync === void 0 ? void 0 : lastSync.toISOString(),\n      syncError,\n      isRetrying\n    });\n  }, [connectionStatus, chats.length, contacts.length, lastSync, syncError, isRetrying]);\n  return {\n    connectionStatus,\n    isConnected: connectionStatus === 'connected',\n    totalChats: chats.length,\n    totalContacts: contacts.length,\n    unreadCount: chats.reduce((total, chat) => total + chat.unreadCount, 0),\n    lastSync,\n    syncError,\n    isRetrying,\n    // Fun√ß√µes principais\n    syncData,\n    syncChats,\n    syncChatMessages,\n    sendMessage: sendMessageWithFallback,\n    connect: connectWhatsApp,\n    disconnect: disconnectWhatsApp,\n    checkStatus: checkWhatsAppStatus,\n    // Fun√ß√£o para for√ßar retry\n    retry: () => {\n      setSyncError(null);\n      setIsRetrying(false);\n      syncData();\n    }\n  };\n};\n_s(useWhatsAppSync, \"OL4A302zUApPtClQw+N03JdcK1Y=\", false, function () {\n  return [useWhatsAppStore];\n});","map":{"version":3,"names":["useState","useCallback","useEffect","useRef","useWhatsAppStore","config","REQUEST_TIMEOUT","RETRY_ATTEMPTS","RETRY_DELAY","SYNC_THROTTLE_INTERVAL","MESSAGE_DUPLICATE_THRESHOLD","STATUS_CHECK_INTERVAL","SYNC_INTERVAL","WHATSAPP_API_BASE","whatsapp","apiUrl","retryRequest","requestFn","maxRetries","baseDelay","lastError","attempt","error","Error","String","delay","Math","pow","random","console","log","Promise","resolve","setTimeout","fetchWithTimeout","url","options","controller","AbortController","timeoutId","abort","response","fetch","signal","headers","clearTimeout","name","useWhatsAppSync","_s","connectionStatus","connectWhatsApp","disconnectWhatsApp","chats","contacts","addMessage","updateChat","loadChatsFromServer","loadMessagesForChat","lastSync","setLastSync","syncError","setSyncError","isRetrying","setIsRetrying","isInitialized","setIsInitialized","syncInProgress","setSyncInProgress","lastOperationTime","setLastOperationTime","syncTimeoutRef","statusTimeoutRef","isInitializingRef","isRecentOperation","operation","threshold","now","Date","checkWhatsAppStatus","whatsappConnected","connected","ok","status","statusText","data","json","isConnected","errorMsg","message","syncChats","Array","isArray","convertedChats","map","serverChat","id","contact","phone","replace","phoneNumber","isOnline","tags","messages","lastMessage","content","body","timestamp","isFromMe","type","undefined","unreadCount","isPinned","isArchived","createdAt","length","syncChatMessages","chatId","encodeURIComponent","convertedMessages","serverMsg","fromMe","hasMedia","sortedMessages","sort","a","b","getTime","slice","m","substring","toISOString","sendMessage","method","JSON","stringify","number","errorData","catch","result","success","newMessage","statusResponse","statusData","getState","updatedChats","chat","updatedMessages","msg","setState","errorMessage","sendMessageFallback","sendMessageWithFallback","fallbackError","syncData","handleReconnect","current","timeout","initialSync","interval","setInterval","clearInterval","reconnectInterval","totalChats","totalContacts","reduce","total","connect","disconnect","checkStatus","retry"],"sources":["/home/cadu/projeto_SPR/frontend/src/hooks/useWhatsAppSync.ts"],"sourcesContent":["import React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { useWhatsAppStore } from '../store/useWhatsAppStore';\nimport { WhatsAppMessage } from '../types';\nimport { config } from '../config';\n\n// Constantes para controle de throttling\nconst REQUEST_TIMEOUT = 15000; // 15 segundos\nconst RETRY_ATTEMPTS = 2;\nconst RETRY_DELAY = 3000; // 3 segundos\nconst SYNC_THROTTLE_INTERVAL = 10000; // 10 segundos (aumentado)\nconst MESSAGE_DUPLICATE_THRESHOLD = 60000; // 1 minuto\nconst STATUS_CHECK_INTERVAL = 15000; // 15 segundos\nconst SYNC_INTERVAL = 30000; // 30 segundos (aumentado)\n\n// URL base para API do WhatsApp\nconst WHATSAPP_API_BASE = config.whatsapp.apiUrl;\n\n// Fun√ß√£o de retry com exponential backoff\nconst retryRequest = async <T>(\n  requestFn: () => Promise<T>, \n  maxRetries: number = RETRY_ATTEMPTS,\n  baseDelay: number = RETRY_DELAY\n): Promise<T> => {\n  let lastError: Error;\n  \n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await requestFn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      \n      if (attempt === maxRetries) {\n        throw lastError;\n      }\n      \n      // Exponential backoff com jitter\n      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;\n      console.log(`‚ö†Ô∏è Tentativa ${attempt + 1} falhou, aguardando ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  \n  throw lastError!;\n};\n\n// Fun√ß√£o de fetch com timeout\nconst fetchWithTimeout = async (url: string, options: RequestInit = {}): Promise<Response> => {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n  \n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n    });\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timeout');\n    }\n    throw error;\n  }\n};\n\nexport const useWhatsAppSync = () => {\n  const { \n    connectionStatus, \n    connectWhatsApp, \n    disconnectWhatsApp,\n    chats,\n    contacts,\n    addMessage,\n    updateChat,\n    loadChatsFromServer,\n    loadMessagesForChat\n  } = useWhatsAppStore();\n  \n  const [lastSync, setLastSync] = useState<Date | null>(null);\n  const [syncError, setSyncError] = useState<string | null>(null);\n  const [isRetrying, setIsRetrying] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [syncInProgress, setSyncInProgress] = useState(false);\n  const [lastOperationTime, setLastOperationTime] = useState<number>(0);\n  \n  // Refs para controle de opera√ß√µes\n  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const statusTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isInitializingRef = useRef(false);\n\n  // Verificar se opera√ß√£o √© muito recente\n  const isRecentOperation = (operation: string, threshold = SYNC_THROTTLE_INTERVAL): boolean => {\n    const now = Date.now();\n    return (now - lastOperationTime) < threshold;\n  };\n\n  // Verificar status da conex√£o WhatsApp com retry\n  const checkWhatsAppStatus = useCallback(async () => {\n    if (isRecentOperation('checkStatus', STATUS_CHECK_INTERVAL)) {\n      console.log('‚ö†Ô∏è Verifica√ß√£o de status muito recente, pulando...');\n      return { whatsappConnected: false, connected: false };\n    }\n\n    try {\n      console.log('üîç Verificando status do WhatsApp...');\n      setLastOperationTime(Date.now());\n      \n      const response = await retryRequest(() => \n        fetchWithTimeout(`${WHATSAPP_API_BASE}/api/status`)\n      );\n      \n      if (!response.ok) {\n        if (response.status === 429) {\n          console.log('‚ö†Ô∏è Rate limit atingido, aguardando...');\n          // Aguardar um pouco antes de tentar novamente\n          await new Promise(resolve => setTimeout(resolve, 2000));\n          throw new Error(`HTTP 429: Rate limit exceeded - aguarde um momento`);\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      console.log('‚úÖ Status do WhatsApp:', data);\n      \n      // Atualizar estado baseado na resposta\n      const isConnected = data.whatsappConnected || data.connected || false;\n      \n      if (isConnected && connectionStatus !== 'connected') {\n        console.log('üîó WhatsApp conectado, atualizando estado...');\n        connectWhatsApp();\n      } else if (!isConnected && connectionStatus === 'connected') {\n        console.log('üîå WhatsApp desconectado, atualizando estado...');\n        disconnectWhatsApp();\n      }\n      \n      setSyncError(null);\n      setIsRetrying(false);\n      return data;\n    } catch (error) {\n      console.error('‚ùå Erro ao verificar status WhatsApp:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      setSyncError(`Erro de conex√£o: ${errorMsg}`);\n      \n      if (connectionStatus === 'connected') {\n        disconnectWhatsApp();\n      }\n      \n      return { whatsappConnected: false, error: errorMsg, connected: false };\n    }\n  }, [connectionStatus, connectWhatsApp, disconnectWhatsApp, isRecentOperation]);\n\n  // Sincronizar chats do servidor WhatsApp real com retry\n  const syncChats = useCallback(async () => {\n    if (isRecentOperation('syncChats', SYNC_THROTTLE_INTERVAL)) {\n      console.log('‚ö†Ô∏è Sincroniza√ß√£o de chats muito recente, pulando...');\n      return [];\n    }\n\n    try {\n      console.log('üîÑ Sincronizando chats do WhatsApp...');\n      setLastOperationTime(Date.now());\n      \n      const response = await retryRequest(() => \n        fetchWithTimeout(`${WHATSAPP_API_BASE}/api/chats`)\n      );\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      if (data.chats && Array.isArray(data.chats)) {\n        // Converter formato do servidor para formato do store\n        const convertedChats = data.chats.map((serverChat: any) => ({\n          id: serverChat.id,\n          contact: {\n            id: serverChat.id,\n            name: serverChat.name || 'Contato',\n            phone: serverChat.id.replace('@c.us', '').replace('@g.us', ''),\n            phoneNumber: serverChat.id.replace('@c.us', '').replace('@g.us', ''),\n            isOnline: false,\n            tags: ['WhatsApp']\n          },\n          messages: [], // Mensagens ser√£o carregadas individualmente\n          lastMessage: serverChat.lastMessage ? {\n            id: 'last-' + serverChat.id,\n            content: typeof serverChat.lastMessage === 'string' \n              ? serverChat.lastMessage \n              : (typeof serverChat.lastMessage === 'object' && serverChat.lastMessage.body \n                ? serverChat.lastMessage.body \n                : 'Mensagem'),\n            timestamp: new Date((serverChat.timestamp || Date.now()) * 1000),\n            isFromMe: false,\n            status: 'read' as const,\n            type: 'text' as const\n          } : undefined,\n          unreadCount: serverChat.unreadCount || 0,\n          isPinned: false,\n          isArchived: false,\n          createdAt: new Date((serverChat.timestamp || Date.now()) * 1000)\n        }));\n\n        console.log(`‚úÖ Sincronizados ${convertedChats.length} chats do WhatsApp`);\n        \n        // ATUALIZAR O STORE com os chats reais\n        loadChatsFromServer(convertedChats);\n        setSyncError(null);\n        \n        return convertedChats;\n      }\n      \n      console.log('‚ö†Ô∏è Nenhum chat encontrado ou formato inv√°lido');\n      return [];\n    } catch (error) {\n      console.error('‚ùå Erro ao sincronizar chats:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      setSyncError(`Erro ao carregar conversas: ${errorMsg}`);\n      throw error;\n    }\n  }, [loadChatsFromServer, isRecentOperation]);\n\n  // Sincronizar mensagens de um chat espec√≠fico com retry\n  const syncChatMessages = useCallback(async (chatId: string) => {\n    try {\n      console.log(`üîÑ Carregando mensagens para chat: ${chatId}`);\n      setLastOperationTime(Date.now());\n      \n      const response = await retryRequest(() => \n        fetchWithTimeout(`${WHATSAPP_API_BASE}/api/chats/${encodeURIComponent(chatId)}/messages?limit=100`)\n      );\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      if (data.messages && Array.isArray(data.messages)) {\n        const convertedMessages = data.messages.map((serverMsg: any) => ({\n          id: serverMsg.id || `msg-${Date.now()}-${Math.random()}`,\n          content: serverMsg.body || serverMsg.content || '',\n          timestamp: new Date((serverMsg.timestamp || Date.now()) * 1000),\n          isFromMe: serverMsg.fromMe || false,\n          status: 'read' as const,\n          type: serverMsg.hasMedia ? 'document' as const : 'text' as const\n        }));\n\n        // Ordenar mensagens por timestamp (mais antiga primeiro para a interface)\n        const sortedMessages = convertedMessages.sort((a, b) => \n          a.timestamp.getTime() - b.timestamp.getTime()\n        );\n\n        console.log(`‚úÖ Carregadas ${sortedMessages.length} mensagens do servidor para chat ${chatId}`);\n        \n        if (sortedMessages.length > 0) {\n          console.log('üìã Primeiras 3 mensagens:', sortedMessages.slice(0, 3).map(m => ({ \n            id: m.id, \n            content: m.content.substring(0, 50),\n            timestamp: m.timestamp.toISOString()\n          })));\n        }\n        \n        // ATUALIZAR O STORE com as mensagens reais (preservando hist√≥rico)\n        loadMessagesForChat(chatId, sortedMessages);\n        \n        return sortedMessages;\n      }\n      \n      console.log(`‚ö†Ô∏è Nenhuma mensagem encontrada no servidor para chat ${chatId}`);\n      return [];\n    } catch (error) {\n      console.error('‚ùå Erro ao sincronizar mensagens:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      throw new Error(`Erro ao carregar mensagens: ${errorMsg}`);\n    }\n  }, [loadMessagesForChat]);\n\n  // Enviar mensagem atrav√©s do servidor WhatsApp com retry\n  const sendMessage = useCallback(async (chatId: string, message: string) => {\n    if (isRecentOperation('sendMessage', 2000)) { // 2 segundos para envio\n      console.log('‚ö†Ô∏è Envio de mensagem muito recente, aguarde...');\n      throw new Error('Envio muito frequente, aguarde um momento');\n    }\n\n    try {\n      console.log(`üì§ Enviando mensagem para ${chatId}: ${message}`);\n      setLastOperationTime(Date.now());\n      \n      const response = await retryRequest(() => \n        fetchWithTimeout(`${WHATSAPP_API_BASE}/api/send-message`, {\n          method: 'POST',\n          body: JSON.stringify({\n            number: chatId,\n            message: message\n          })\n        })\n      );\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Erro ao enviar mensagem');\n      }\n\n      console.log('‚úÖ Mensagem enviada com sucesso');\n      \n      // Adicionar mensagem ao store localmente para feedback imediato\n      const newMessage: WhatsAppMessage = {\n        id: `sent-${Date.now()}-${Math.random()}`,\n        content: message,\n        timestamp: new Date(),\n        isFromMe: true,\n        status: 'sent' as const,\n        type: 'text' as const\n      };\n      \n      addMessage(chatId, newMessage);\n      \n      // Aguardar um pouco e verificar se a mensagem foi realmente enviada\n      setTimeout(async () => {\n        try {\n          console.log('üîÑ Verificando se mensagem foi enviada com sucesso...');\n          \n          // Verificar status da mensagem no servidor\n          const statusResponse = await fetchWithTimeout(`${WHATSAPP_API_BASE}/api/status`);\n          if (statusResponse.ok) {\n            const statusData = await statusResponse.json();\n            console.log('‚úÖ Servidor WhatsApp confirmou envio');\n            \n            // For√ßar sincroniza√ß√£o das mensagens para garantir que apare√ßa\n            setTimeout(async () => {\n              try {\n                console.log('üîÑ Sincronizando mensagens ap√≥s envio...');\n                await syncChatMessages(chatId);\n              } catch (error) {\n                console.error('‚ö†Ô∏è Erro na sincroniza√ß√£o p√≥s-envio:', error);\n              }\n            }, 2000);\n            \n            // Atualizar status da mensagem para 'delivered'\n            const { chats } = useWhatsAppStore.getState();\n            const updatedChats = chats.map(chat => {\n              if (chat.id === chatId) {\n                const updatedMessages = chat.messages.map(msg => {\n                  if (msg.id === newMessage.id) {\n                    return { ...msg, status: 'delivered' as const };\n                  }\n                  return msg;\n                });\n                return { ...chat, messages: updatedMessages };\n              }\n              return chat;\n            });\n            useWhatsAppStore.setState({ chats: updatedChats });\n          }\n        } catch (error) {\n          console.error('‚ö†Ô∏è Erro ao verificar status da mensagem:', error);\n        }\n      }, 3000); // Aguardar 3 segundos para o servidor processar\n      \n      return true;\n    } catch (error) {\n      console.error('‚ùå Erro ao enviar mensagem:', error);\n      const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n      \n      // Adicionar mensagem de erro local\n      const errorMessage: WhatsAppMessage = {\n        id: `error-${Date.now()}-${Math.random()}`,\n        content: `‚ùå Erro ao enviar: ${errorMsg}`,\n        timestamp: new Date(),\n        isFromMe: false,\n        status: 'read' as const,\n        type: 'text' as const\n      };\n      \n      addMessage(chatId, errorMessage);\n      \n      throw new Error(`Falha no envio: ${errorMsg}`);\n    }\n  }, [addMessage, isRecentOperation, syncChatMessages]);\n\n  // Fun√ß√£o de fallback para envio via endpoint alternativo\n  const sendMessageFallback = useCallback(async (chatId: string, message: string) => {\n    try {\n      console.log(`üì§ Tentando envio via endpoint alternativo para ${chatId}: ${message}`);\n      \n      const response = await retryRequest(() => \n        fetchWithTimeout(`${WHATSAPP_API_BASE}/api/whatsapp/send`, {\n          method: 'POST',\n          body: JSON.stringify({\n            number: chatId,\n            message: message\n          })\n        })\n      );\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Erro ao enviar mensagem');\n      }\n\n      console.log('‚úÖ Mensagem enviada via endpoint alternativo');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Erro no endpoint alternativo:', error);\n      throw error;\n    }\n  }, []);\n\n  // Fun√ß√£o de envio com fallback\n  const sendMessageWithFallback = useCallback(async (chatId: string, message: string) => {\n    try {\n      return await sendMessage(chatId, message);\n    } catch (error) {\n      console.log('‚ö†Ô∏è Primeiro endpoint falhou, tentando alternativo...');\n      try {\n        return await sendMessageFallback(chatId, message);\n      } catch (fallbackError) {\n        console.error('‚ùå Ambos os endpoints falharam:', fallbackError);\n        throw fallbackError;\n      }\n    }\n  }, [sendMessage, sendMessageFallback]);\n\n  // Sincroniza√ß√£o autom√°tica quando conectado (COM DEBOUNCE)\n  const syncData = useCallback(async () => {\n    if (connectionStatus === 'connected' && !syncInProgress) {\n      try {\n        console.log('üîÑ Sincronizando dados do WhatsApp...');\n        setSyncInProgress(true);\n        \n        // Verificar status primeiro\n        const status = await checkWhatsAppStatus();\n        \n        if (status.whatsappConnected || status.connected) {\n          // S√≥ sincronizar se WhatsApp estiver conectado\n          const chats = await syncChats();\n          setLastSync(new Date());\n          setSyncError(null);\n          console.log('‚úÖ Sincroniza√ß√£o conclu√≠da');\n          \n          // Sincronizar mensagens de todos os chats\n          if (chats.length > 0) {\n            console.log('üîÑ Sincronizando mensagens de todos os chats...');\n            for (const chat of chats) {\n              try {\n                await syncChatMessages(chat.id);\n              } catch (error) {\n                console.error(`‚ùå Erro ao sincronizar mensagens do chat ${chat.id}:`, error);\n              }\n            }\n          }\n        } else {\n          console.log('‚ö†Ô∏è WhatsApp n√£o conectado, pulando sincroniza√ß√£o');\n          setSyncError('WhatsApp n√£o conectado no servidor');\n        }\n      } catch (error) {\n        console.error('‚ùå Erro na sincroniza√ß√£o:', error);\n        const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';\n        setSyncError(`Erro na sincroniza√ß√£o: ${errorMsg}`);\n      } finally {\n        setSyncInProgress(false);\n      }\n    }\n  }, [connectionStatus, checkWhatsAppStatus, syncChats, syncChatMessages, syncInProgress]);\n\n  // Auto-reconex√£o em caso de desconex√£o\n  const handleReconnect = useCallback(async () => {\n    if (connectionStatus === 'error' || connectionStatus === 'disconnected') {\n      console.log('üîÑ Verificando possibilidade de reconex√£o...');\n      setIsRetrying(true);\n      \n      try {\n        const status = await checkWhatsAppStatus();\n        if (status.whatsappConnected || status.connected) {\n          console.log('‚úÖ Reconectando WhatsApp...');\n          connectWhatsApp();\n        } else {\n          console.log('‚ö†Ô∏è WhatsApp ainda n√£o conectado no servidor');\n        }\n      } catch (error) {\n        console.log('‚ö†Ô∏è Servidor WhatsApp indispon√≠vel, tentando novamente em breve...');\n      } finally {\n        setIsRetrying(false);\n      }\n    }\n  }, [connectionStatus, checkWhatsAppStatus, connectWhatsApp]);\n\n  // Efeito para verifica√ß√£o inicial (apenas uma vez)\n  useEffect(() => {\n    if (!isInitialized && !isInitializingRef.current) {\n      console.log('üöÄ Inicializando useWhatsAppSync...');\n      isInitializingRef.current = true;\n      setIsInitialized(true);\n      \n      // Delay para evitar chamadas simult√¢neas\n      const timeout = setTimeout(() => {\n        checkWhatsAppStatus();\n        isInitializingRef.current = false;\n      }, 2000); // Aumentado para 2 segundos\n      \n      return () => {\n        clearTimeout(timeout);\n        isInitializingRef.current = false;\n      };\n    }\n  }, [isInitialized, checkWhatsAppStatus]);\n\n  // Efeito para sincroniza√ß√£o autom√°tica quando conectado (COM DEBOUNCE)\n  useEffect(() => {\n    if (connectionStatus === 'connected' && !syncInProgress) {\n      console.log('üîó WhatsApp conectado, iniciando sincroniza√ß√£o autom√°tica...');\n      \n      // Primeira sincroniza√ß√£o imediata\n      const initialSync = setTimeout(() => {\n        if (connectionStatus === 'connected') {\n          syncData();\n        }\n      }, 1000); // Delay reduzido para 1 segundo\n      \n      // Sincroniza√ß√£o peri√≥dica mais frequente\n      const interval = setInterval(() => {\n        if (connectionStatus === 'connected' && !syncInProgress) {\n          syncData();\n        }\n      }, 10000); // A cada 10 segundos\n      \n      return () => {\n        console.log('üõë Parando sincroniza√ß√£o autom√°tica');\n        clearTimeout(initialSync);\n        clearInterval(interval);\n      };\n    }\n  }, [connectionStatus, syncData, syncInProgress]);\n\n  // Efeito para verifica√ß√£o peri√≥dica de status (separado da sincroniza√ß√£o)\n  useEffect(() => {\n    if (connectionStatus === 'connected') {\n      // Limpar timeout anterior\n      if (statusTimeoutRef.current) {\n        clearTimeout(statusTimeoutRef.current);\n      }\n      \n      // Verifica√ß√£o peri√≥dica de status\n      statusTimeoutRef.current = setTimeout(() => {\n        if (connectionStatus === 'connected') {\n          checkWhatsAppStatus();\n        }\n      }, STATUS_CHECK_INTERVAL);\n      \n      return () => {\n        if (statusTimeoutRef.current) {\n          clearTimeout(statusTimeoutRef.current);\n        }\n      };\n    }\n  }, [connectionStatus, checkWhatsAppStatus]);\n\n  // Efeito para tentativa de reconex√£o (com debounce maior)\n  useEffect(() => {\n    if (connectionStatus === 'error' || connectionStatus === 'disconnected') {\n      // Delay maior para evitar spam de reconex√£o\n      const timeout = setTimeout(handleReconnect, config.whatsapp.reconnectInterval * 3);\n      return () => clearTimeout(timeout);\n    }\n  }, [connectionStatus, handleReconnect]);\n\n  // Debug: log do estado atual\n  useEffect(() => {\n    console.log('üìä Estado useWhatsAppSync:', {\n      connectionStatus,\n      totalChats: chats.length,\n      totalContacts: contacts.length,\n      lastSync: lastSync?.toISOString(),\n      syncError,\n      isRetrying\n    });\n  }, [connectionStatus, chats.length, contacts.length, lastSync, syncError, isRetrying]);\n\n  return {\n    connectionStatus,\n    isConnected: connectionStatus === 'connected',\n    totalChats: chats.length,\n    totalContacts: contacts.length,\n    unreadCount: chats.reduce((total, chat) => total + chat.unreadCount, 0),\n    lastSync,\n    syncError,\n    isRetrying,\n    \n    // Fun√ß√µes principais\n    syncData,\n    syncChats,\n    syncChatMessages,\n    sendMessage: sendMessageWithFallback,\n    connect: connectWhatsApp,\n    disconnect: disconnectWhatsApp,\n    checkStatus: checkWhatsAppStatus,\n    \n    // Fun√ß√£o para for√ßar retry\n    retry: () => {\n      setSyncError(null);\n      setIsRetrying(false);\n      syncData();\n    }\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}