{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { useWhatsAppStore } from '../store/useWhatsAppStore';\nconst REFRESH_INTERVAL = 30000; // 30 segundos\n\nexport const useDashboardData = () => {\n  _s();\n  const {\n    contacts,\n    chats,\n    connectionStatus,\n    isConnected\n  } = useWhatsAppStore();\n  const [dashboardData, setDashboardData] = useState({\n    totalMessages: 0,\n    totalContacts: 0,\n    activeChats: 0,\n    messagesPerDay: 0,\n    responseTime: 0,\n    deliveryRate: 0,\n    readRate: 0,\n    connectionStatus: 'disconnected',\n    lastUpdate: new Date(),\n    messageHistory: [],\n    recentActivity: []\n  });\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Calcular métricas baseadas nos dados reais\n  const calculateMetrics = () => {\n    if (!chats || chats.length === 0) {\n      return {\n        totalMessages: 0,\n        totalContacts: (contacts === null || contacts === void 0 ? void 0 : contacts.length) || 0,\n        activeChats: 0,\n        messagesPerDay: 0,\n        responseTime: 0,\n        deliveryRate: 0,\n        readRate: 0\n      };\n    }\n\n    // Calcular total de mensagens\n    const totalMessages = chats.reduce((total, chat) => total + chat.messages.length, 0);\n\n    // Calcular chats ativos (com mensagens nas últimas 24h)\n    const now = new Date();\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    const activeChats = chats.filter(chat => chat.lastMessage && new Date(chat.lastMessage.timestamp) > oneDayAgo).length;\n\n    // Calcular mensagens por dia (últimas 24h)\n    const messagesLastDay = chats.reduce((total, chat) => {\n      const recentMessages = chat.messages.filter(msg => new Date(msg.timestamp) > oneDayAgo);\n      return total + recentMessages.length;\n    }, 0);\n\n    // Calcular tempo de resposta médio (em minutos)\n    let totalResponseTime = 0;\n    let responseCount = 0;\n    chats.forEach(chat => {\n      const messages = chat.messages.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n      for (let i = 1; i < messages.length; i++) {\n        const current = messages[i];\n        const previous = messages[i - 1];\n\n        // Se a mensagem atual é nossa resposta à mensagem anterior de outro\n        if (current.isFromMe && !previous.isFromMe) {\n          const responseTime = new Date(current.timestamp).getTime() - new Date(previous.timestamp).getTime();\n          totalResponseTime += responseTime;\n          responseCount++;\n        }\n      }\n    });\n    const avgResponseTime = responseCount > 0 ? Math.round(totalResponseTime / responseCount / 60000) // converter para minutos\n    : 0;\n\n    // Calcular taxa de entrega\n    const totalSentMessages = chats.reduce((total, chat) => {\n      return total + chat.messages.filter(msg => msg.isFromMe).length;\n    }, 0);\n    const deliveredMessages = chats.reduce((total, chat) => {\n      return total + chat.messages.filter(msg => msg.isFromMe && (msg.status === 'delivered' || msg.status === 'read')).length;\n    }, 0);\n    const deliveryRate = totalSentMessages > 0 ? Math.round(deliveredMessages / totalSentMessages * 100) : 0;\n\n    // Calcular taxa de leitura\n    const readMessages = chats.reduce((total, chat) => {\n      return total + chat.messages.filter(msg => msg.isFromMe && msg.status === 'read').length;\n    }, 0);\n    const readRate = totalSentMessages > 0 ? Math.round(readMessages / totalSentMessages * 100) : 0;\n    return {\n      totalMessages,\n      totalContacts: (contacts === null || contacts === void 0 ? void 0 : contacts.length) || 0,\n      activeChats,\n      messagesPerDay: messagesLastDay,\n      responseTime: avgResponseTime,\n      deliveryRate,\n      readRate\n    };\n  };\n\n  // Gerar histórico de mensagens dos últimos 7 dias\n  const generateMessageHistory = () => {\n    const history = [];\n    const now = new Date();\n    for (let i = 6; i >= 0; i--) {\n      const date = new Date(now);\n      date.setDate(date.getDate() - i);\n      const dayStart = new Date(date);\n      dayStart.setHours(0, 0, 0, 0);\n      const dayEnd = new Date(date);\n      dayEnd.setHours(23, 59, 59, 999);\n      let sent = 0;\n      let received = 0;\n      chats.forEach(chat => {\n        chat.messages.forEach(msg => {\n          const msgDate = new Date(msg.timestamp);\n          if (msgDate >= dayStart && msgDate <= dayEnd) {\n            if (msg.isFromMe) {\n              sent++;\n            } else {\n              received++;\n            }\n          }\n        });\n      });\n      history.push({\n        date: date.toLocaleDateString('pt-BR', {\n          weekday: 'short'\n        }),\n        sent,\n        received\n      });\n    }\n    return history;\n  };\n\n  // Gerar atividades recentes\n  const generateRecentActivity = () => {\n    const activities = [];\n    const now = new Date();\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n\n    // Mensagens recentes\n    const recentMessages = chats.reduce((acc, chat) => {\n      const recent = chat.messages.filter(msg => new Date(msg.timestamp) > oneHourAgo && !msg.isFromMe);\n      return acc + recent.length;\n    }, 0);\n    if (recentMessages > 0) {\n      activities.push({\n        id: 'recent-messages',\n        type: 'message',\n        description: `${recentMessages} nova${recentMessages > 1 ? 's' : ''} mensagem${recentMessages > 1 ? 'ns' : ''} recebida${recentMessages > 1 ? 's' : ''}`,\n        timestamp: new Date(),\n        severity: 'info'\n      });\n    }\n\n    // Status da conexão\n    activities.push({\n      id: 'connection-status',\n      type: 'system',\n      description: isConnected ? 'WhatsApp conectado e funcionando' : 'WhatsApp desconectado',\n      timestamp: new Date(),\n      severity: isConnected ? 'success' : 'error'\n    });\n\n    // Contatos ativos\n    const activeContactsCount = chats.filter(chat => chat.lastMessage && new Date(chat.lastMessage.timestamp) > oneHourAgo).length;\n    if (activeContactsCount > 0) {\n      activities.push({\n        id: 'active-contacts',\n        type: 'contact',\n        description: `${activeContactsCount} contato${activeContactsCount > 1 ? 's' : ''} ativo${activeContactsCount > 1 ? 's' : ''} na última hora`,\n        timestamp: new Date(),\n        severity: 'success'\n      });\n    }\n    return activities.slice(0, 5); // Limitar a 5 atividades\n  };\n\n  // Buscar dados do servidor\n  const fetchServerMetrics = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Aguardar um pouco para garantir que o servidor esteja pronto\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Buscar status do servidor\n      const statusResponse = await fetch('http://localhost:3002/api/status', {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!statusResponse.ok) {\n        throw new Error(`HTTP ${statusResponse.status}: ${statusResponse.statusText}`);\n      }\n      const statusData = await statusResponse.json();\n\n      // Buscar métricas específicas se disponível\n      let serverMetrics = {};\n      try {\n        const metricsResponse = await fetch('http://localhost:3002/api/metrics', {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        });\n        if (metricsResponse.ok) {\n          const metricsData = await metricsResponse.json();\n          serverMetrics = metricsData.metrics || {};\n        } else {\n          console.log(`Métricas não disponíveis: ${metricsResponse.status}`);\n        }\n      } catch (error) {\n        console.log('Métricas do servidor não disponíveis, usando cálculos locais:', error instanceof Error ? error.message : String(error));\n      }\n      const calculatedMetrics = calculateMetrics();\n      const messageHistory = generateMessageHistory();\n      const recentActivity = generateRecentActivity();\n      setDashboardData({\n        totalMessages: calculatedMetrics.totalMessages || 0,\n        totalContacts: calculatedMetrics.totalContacts || 0,\n        activeChats: calculatedMetrics.activeChats || 0,\n        messagesPerDay: calculatedMetrics.messagesPerDay || 0,\n        responseTime: calculatedMetrics.responseTime || 0,\n        deliveryRate: calculatedMetrics.deliveryRate || 0,\n        readRate: calculatedMetrics.readRate || 0,\n        ...serverMetrics,\n        // Sobrescrever com dados do servidor se disponível\n        connectionStatus,\n        lastUpdate: new Date(),\n        messageHistory,\n        recentActivity\n      });\n    } catch (error) {\n      console.error('Erro ao buscar métricas:', error instanceof Error ? error.message : String(error));\n      setError('Erro ao carregar dados do dashboard');\n\n      // Usar dados locais como fallback\n      const calculatedMetrics = calculateMetrics();\n      const messageHistory = generateMessageHistory();\n      const recentActivity = generateRecentActivity();\n      setDashboardData({\n        totalMessages: calculatedMetrics.totalMessages || 0,\n        totalContacts: calculatedMetrics.totalContacts || 0,\n        activeChats: calculatedMetrics.activeChats || 0,\n        messagesPerDay: calculatedMetrics.messagesPerDay || 0,\n        responseTime: calculatedMetrics.responseTime || 0,\n        deliveryRate: calculatedMetrics.deliveryRate || 0,\n        readRate: calculatedMetrics.readRate || 0,\n        connectionStatus: 'error',\n        lastUpdate: new Date(),\n        messageHistory,\n        recentActivity\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Atualizar dados quando os dados do WhatsApp mudarem\n  useEffect(() => {\n    const calculatedMetrics = calculateMetrics();\n    const messageHistory = generateMessageHistory();\n    const recentActivity = generateRecentActivity();\n    setDashboardData(prev => ({\n      ...prev,\n      ...calculatedMetrics,\n      connectionStatus,\n      lastUpdate: new Date(),\n      messageHistory,\n      recentActivity\n    }));\n  }, [contacts, chats, connectionStatus, isConnected]);\n\n  // Buscar dados do servidor periodicamente\n  useEffect(() => {\n    fetchServerMetrics();\n    const interval = setInterval(fetchServerMetrics, REFRESH_INTERVAL);\n    return () => clearInterval(interval);\n  }, []);\n  return {\n    data: dashboardData,\n    loading,\n    error,\n    refresh: fetchServerMetrics\n  };\n};\n_s(useDashboardData, \"RCrw9pmJmgPcqF21b76sU+ad6DE=\", false, function () {\n  return [useWhatsAppStore];\n});","map":{"version":3,"names":["useState","useEffect","useWhatsAppStore","REFRESH_INTERVAL","useDashboardData","_s","contacts","chats","connectionStatus","isConnected","dashboardData","setDashboardData","totalMessages","totalContacts","activeChats","messagesPerDay","responseTime","deliveryRate","readRate","lastUpdate","Date","messageHistory","recentActivity","loading","setLoading","error","setError","calculateMetrics","length","reduce","total","chat","messages","now","oneDayAgo","getTime","filter","lastMessage","timestamp","messagesLastDay","recentMessages","msg","totalResponseTime","responseCount","forEach","sort","a","b","i","current","previous","isFromMe","avgResponseTime","Math","round","totalSentMessages","deliveredMessages","status","readMessages","generateMessageHistory","history","date","setDate","getDate","dayStart","setHours","dayEnd","sent","received","msgDate","push","toLocaleDateString","weekday","generateRecentActivity","activities","oneHourAgo","acc","recent","id","type","description","severity","activeContactsCount","slice","fetchServerMetrics","Promise","resolve","setTimeout","statusResponse","fetch","method","headers","ok","Error","statusText","statusData","json","serverMetrics","metricsResponse","metricsData","metrics","console","log","message","String","calculatedMetrics","prev","interval","setInterval","clearInterval","data","refresh"],"sources":["/home/cadu/projeto_SPR/frontend/src/hooks/useDashboardData.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { useWhatsAppStore } from '../store/useWhatsAppStore';\r\nimport { DashboardMetrics } from '../types';\r\n\r\ninterface DashboardData extends DashboardMetrics {\r\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\r\n  lastUpdate: Date;\r\n  messageHistory: Array<{\r\n    date: string;\r\n    sent: number;\r\n    received: number;\r\n  }>;\r\n  recentActivity: Array<{\r\n    id: string;\r\n    type: 'message' | 'contact' | 'system';\r\n    description: string;\r\n    timestamp: Date;\r\n    severity: 'info' | 'warning' | 'success' | 'error';\r\n  }>;\r\n}\r\n\r\nconst REFRESH_INTERVAL = 30000; // 30 segundos\r\n\r\nexport const useDashboardData = () => {\r\n  const { \r\n    contacts, \r\n    chats, \r\n    connectionStatus, \r\n    isConnected\r\n  } = useWhatsAppStore();\r\n\r\n  const [dashboardData, setDashboardData] = useState<DashboardData>({\r\n    totalMessages: 0,\r\n    totalContacts: 0,\r\n    activeChats: 0,\r\n    messagesPerDay: 0,\r\n    responseTime: 0,\r\n    deliveryRate: 0,\r\n    readRate: 0,\r\n    connectionStatus: 'disconnected',\r\n    lastUpdate: new Date(),\r\n    messageHistory: [],\r\n    recentActivity: []\r\n  });\r\n\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Calcular métricas baseadas nos dados reais\r\n  const calculateMetrics = (): Partial<DashboardData> => {\r\n    if (!chats || chats.length === 0) {\r\n      return {\r\n        totalMessages: 0,\r\n        totalContacts: contacts?.length || 0,\r\n        activeChats: 0,\r\n        messagesPerDay: 0,\r\n        responseTime: 0,\r\n        deliveryRate: 0,\r\n        readRate: 0\r\n      };\r\n    }\r\n\r\n    // Calcular total de mensagens\r\n    const totalMessages = chats.reduce((total, chat) => total + chat.messages.length, 0);\r\n\r\n    // Calcular chats ativos (com mensagens nas últimas 24h)\r\n    const now = new Date();\r\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n    const activeChats = chats.filter(chat => \r\n      chat.lastMessage && new Date(chat.lastMessage.timestamp) > oneDayAgo\r\n    ).length;\r\n\r\n    // Calcular mensagens por dia (últimas 24h)\r\n    const messagesLastDay = chats.reduce((total, chat) => {\r\n      const recentMessages = chat.messages.filter(msg => \r\n        new Date(msg.timestamp) > oneDayAgo\r\n      );\r\n      return total + recentMessages.length;\r\n    }, 0);\r\n\r\n    // Calcular tempo de resposta médio (em minutos)\r\n    let totalResponseTime = 0;\r\n    let responseCount = 0;\r\n    \r\n    chats.forEach(chat => {\r\n      const messages = chat.messages.sort((a, b) => \r\n        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\r\n      );\r\n      \r\n      for (let i = 1; i < messages.length; i++) {\r\n        const current = messages[i];\r\n        const previous = messages[i - 1];\r\n        \r\n        // Se a mensagem atual é nossa resposta à mensagem anterior de outro\r\n        if (current.isFromMe && !previous.isFromMe) {\r\n          const responseTime = new Date(current.timestamp).getTime() - \r\n                              new Date(previous.timestamp).getTime();\r\n          totalResponseTime += responseTime;\r\n          responseCount++;\r\n        }\r\n      }\r\n    });\r\n\r\n    const avgResponseTime = responseCount > 0 \r\n      ? Math.round(totalResponseTime / responseCount / 60000) // converter para minutos\r\n      : 0;\r\n\r\n    // Calcular taxa de entrega\r\n    const totalSentMessages = chats.reduce((total, chat) => {\r\n      return total + chat.messages.filter(msg => msg.isFromMe).length;\r\n    }, 0);\r\n\r\n    const deliveredMessages = chats.reduce((total, chat) => {\r\n      return total + chat.messages.filter(msg => \r\n        msg.isFromMe && (msg.status === 'delivered' || msg.status === 'read')\r\n      ).length;\r\n    }, 0);\r\n\r\n    const deliveryRate = totalSentMessages > 0 \r\n      ? Math.round((deliveredMessages / totalSentMessages) * 100)\r\n      : 0;\r\n\r\n    // Calcular taxa de leitura\r\n    const readMessages = chats.reduce((total, chat) => {\r\n      return total + chat.messages.filter(msg => \r\n        msg.isFromMe && msg.status === 'read'\r\n      ).length;\r\n    }, 0);\r\n\r\n    const readRate = totalSentMessages > 0 \r\n      ? Math.round((readMessages / totalSentMessages) * 100)\r\n      : 0;\r\n\r\n    return {\r\n      totalMessages,\r\n      totalContacts: contacts?.length || 0,\r\n      activeChats,\r\n      messagesPerDay: messagesLastDay,\r\n      responseTime: avgResponseTime,\r\n      deliveryRate,\r\n      readRate\r\n    };\r\n  };\r\n\r\n  // Gerar histórico de mensagens dos últimos 7 dias\r\n  const generateMessageHistory = (): Array<{\r\n    date: string;\r\n    sent: number;\r\n    received: number;\r\n  }> => {\r\n    const history: Array<{\r\n      date: string;\r\n      sent: number;\r\n      received: number;\r\n    }> = [];\r\n    const now = new Date();\r\n    \r\n    for (let i = 6; i >= 0; i--) {\r\n      const date = new Date(now);\r\n      date.setDate(date.getDate() - i);\r\n      const dayStart = new Date(date);\r\n      dayStart.setHours(0, 0, 0, 0);\r\n      const dayEnd = new Date(date);\r\n      dayEnd.setHours(23, 59, 59, 999);\r\n\r\n      let sent = 0;\r\n      let received = 0;\r\n\r\n      chats.forEach(chat => {\r\n        chat.messages.forEach(msg => {\r\n          const msgDate = new Date(msg.timestamp);\r\n          if (msgDate >= dayStart && msgDate <= dayEnd) {\r\n            if (msg.isFromMe) {\r\n              sent++;\r\n            } else {\r\n              received++;\r\n            }\r\n          }\r\n        });\r\n      });\r\n\r\n      history.push({\r\n        date: date.toLocaleDateString('pt-BR', { weekday: 'short' }),\r\n        sent,\r\n        received\r\n      });\r\n    }\r\n\r\n    return history;\r\n  };\r\n\r\n  // Gerar atividades recentes\r\n  const generateRecentActivity = (): Array<{\r\n    id: string;\r\n    type: 'message' | 'contact' | 'system';\r\n    description: string;\r\n    timestamp: Date;\r\n    severity: 'info' | 'warning' | 'success' | 'error';\r\n  }> => {\r\n    const activities: Array<{\r\n      id: string;\r\n      type: 'message' | 'contact' | 'system';\r\n      description: string;\r\n      timestamp: Date;\r\n      severity: 'info' | 'warning' | 'success' | 'error';\r\n    }> = [];\r\n    const now = new Date();\r\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\r\n\r\n    // Mensagens recentes\r\n    const recentMessages = chats.reduce((acc, chat) => {\r\n      const recent = chat.messages.filter(msg => \r\n        new Date(msg.timestamp) > oneHourAgo && !msg.isFromMe\r\n      );\r\n      return acc + recent.length;\r\n    }, 0);\r\n\r\n    if (recentMessages > 0) {\r\n      activities.push({\r\n        id: 'recent-messages',\r\n        type: 'message' as const,\r\n        description: `${recentMessages} nova${recentMessages > 1 ? 's' : ''} mensagem${recentMessages > 1 ? 'ns' : ''} recebida${recentMessages > 1 ? 's' : ''}`,\r\n        timestamp: new Date(),\r\n        severity: 'info' as const\r\n      });\r\n    }\r\n\r\n    // Status da conexão\r\n    activities.push({\r\n      id: 'connection-status',\r\n      type: 'system' as const,\r\n      description: isConnected \r\n        ? 'WhatsApp conectado e funcionando' \r\n        : 'WhatsApp desconectado',\r\n      timestamp: new Date(),\r\n      severity: isConnected ? 'success' as const : 'error' as const\r\n    });\r\n\r\n    // Contatos ativos\r\n    const activeContactsCount = chats.filter(chat => \r\n      chat.lastMessage && new Date(chat.lastMessage.timestamp) > oneHourAgo\r\n    ).length;\r\n\r\n    if (activeContactsCount > 0) {\r\n      activities.push({\r\n        id: 'active-contacts',\r\n        type: 'contact' as const,\r\n        description: `${activeContactsCount} contato${activeContactsCount > 1 ? 's' : ''} ativo${activeContactsCount > 1 ? 's' : ''} na última hora`,\r\n        timestamp: new Date(),\r\n        severity: 'success' as const\r\n      });\r\n    }\r\n\r\n    return activities.slice(0, 5); // Limitar a 5 atividades\r\n  };\r\n\r\n  // Buscar dados do servidor\r\n  const fetchServerMetrics = async () => {\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n\r\n      // Aguardar um pouco para garantir que o servidor esteja pronto\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n      // Buscar status do servidor\r\n      const statusResponse = await fetch('http://localhost:3002/api/status', {\r\n        method: 'GET',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n      \r\n      if (!statusResponse.ok) {\r\n        throw new Error(`HTTP ${statusResponse.status}: ${statusResponse.statusText}`);\r\n      }\r\n      \r\n      const statusData = await statusResponse.json();\r\n\r\n      // Buscar métricas específicas se disponível\r\n      let serverMetrics = {};\r\n      try {\r\n        const metricsResponse = await fetch('http://localhost:3002/api/metrics', {\r\n          method: 'GET',\r\n          headers: {\r\n            'Content-Type': 'application/json'\r\n          }\r\n        });\r\n        \r\n        if (metricsResponse.ok) {\r\n          const metricsData = await metricsResponse.json();\r\n          serverMetrics = metricsData.metrics || {};\r\n        } else {\r\n          console.log(`Métricas não disponíveis: ${metricsResponse.status}`);\r\n        }\r\n              } catch (error) {\r\n          console.log('Métricas do servidor não disponíveis, usando cálculos locais:', error instanceof Error ? error.message : String(error));\r\n        }\r\n\r\n      const calculatedMetrics = calculateMetrics();\r\n      const messageHistory = generateMessageHistory();\r\n      const recentActivity = generateRecentActivity();\r\n\r\n      setDashboardData({\r\n        totalMessages: calculatedMetrics.totalMessages || 0,\r\n        totalContacts: calculatedMetrics.totalContacts || 0,\r\n        activeChats: calculatedMetrics.activeChats || 0,\r\n        messagesPerDay: calculatedMetrics.messagesPerDay || 0,\r\n        responseTime: calculatedMetrics.responseTime || 0,\r\n        deliveryRate: calculatedMetrics.deliveryRate || 0,\r\n        readRate: calculatedMetrics.readRate || 0,\r\n        ...serverMetrics, // Sobrescrever com dados do servidor se disponível\r\n        connectionStatus,\r\n        lastUpdate: new Date(),\r\n        messageHistory,\r\n        recentActivity\r\n      });\r\n\r\n    } catch (error) {\r\n      console.error('Erro ao buscar métricas:', error instanceof Error ? error.message : String(error));\r\n      setError('Erro ao carregar dados do dashboard');\r\n      \r\n      // Usar dados locais como fallback\r\n      const calculatedMetrics = calculateMetrics();\r\n      const messageHistory = generateMessageHistory();\r\n      const recentActivity = generateRecentActivity();\r\n\r\n      setDashboardData({\r\n        totalMessages: calculatedMetrics.totalMessages || 0,\r\n        totalContacts: calculatedMetrics.totalContacts || 0,\r\n        activeChats: calculatedMetrics.activeChats || 0,\r\n        messagesPerDay: calculatedMetrics.messagesPerDay || 0,\r\n        responseTime: calculatedMetrics.responseTime || 0,\r\n        deliveryRate: calculatedMetrics.deliveryRate || 0,\r\n        readRate: calculatedMetrics.readRate || 0,\r\n        connectionStatus: 'error',\r\n        lastUpdate: new Date(),\r\n        messageHistory,\r\n        recentActivity\r\n      });\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Atualizar dados quando os dados do WhatsApp mudarem\r\n  useEffect(() => {\r\n    const calculatedMetrics = calculateMetrics();\r\n    const messageHistory = generateMessageHistory();\r\n    const recentActivity = generateRecentActivity();\r\n\r\n    setDashboardData(prev => ({\r\n      ...prev,\r\n      ...calculatedMetrics,\r\n      connectionStatus,\r\n      lastUpdate: new Date(),\r\n      messageHistory,\r\n      recentActivity\r\n    }));\r\n  }, [contacts, chats, connectionStatus, isConnected]);\r\n\r\n  // Buscar dados do servidor periodicamente\r\n  useEffect(() => {\r\n    fetchServerMetrics();\r\n    \r\n    const interval = setInterval(fetchServerMetrics, REFRESH_INTERVAL);\r\n    \r\n    return () => clearInterval(interval);\r\n  }, []);\r\n\r\n  return {\r\n    data: dashboardData,\r\n    loading,\r\n    error,\r\n    refresh: fetchServerMetrics\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}